name: 'Next.js Turbopack Bundle Size'
description: 'Tracks bundle size changes across PRs for Next.js apps built with Turbopack'
author: 'michalsanger'

branding:
  icon: 'package'
  color: 'blue'

inputs:
  github-token:
    description: 'GitHub token for downloading baseline artifact and posting PR comments'
    required: true
  stats-path:
    description: 'Path to the Turbopack webpack-stats.json generated by the build'
    required: false
    default: '.next/server/webpack-stats.json'
  artifact-name:
    description: 'Artifact name used to store and retrieve the baseline stats from the main branch'
    required: false
    default: 'turbopack-main-stats'

runs:
  using: composite
  steps:
    - name: Upload baseline stats
      if: github.ref == 'refs/heads/main'
      uses: actions/upload-artifact@v6.0.0
      with:
        name: ${{ inputs.artifact-name }}
        path: ${{ inputs.stats-path }}
        overwrite: true

    - name: Download baseline stats
      if: github.event_name == 'pull_request'
      uses: dawidd6/action-download-artifact@v15
      continue-on-error: true
      with:
        github_token: ${{ inputs.github-token }}
        branch: main
        name: ${{ inputs.artifact-name }}
        path: _bundle-baseline-stats

    - name: Calculate bundle sizes and diff
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v8.0.0
      env:
        STATS_PATH: ${{ inputs.stats-path }}
      with:
        script: |
          const fs = require("fs");
          const path = require("path");
          const zlib = require("zlib");

          const statsPath = process.env.STATS_PATH;

          const formatBytes = (bytes) => {
            if (bytes === 0) return "0 B";
            const k = 1024;
            const sizes = ["B", "KB", "MB"];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
          };

          const formatDiff = (current, baseline) => {
            if (baseline === undefined) return "üÜï New";
            const diff = current - baseline;
            if (diff === 0) return "‚ûñ No change";
            const sign = diff > 0 ? "üî¥ +" : "üü¢ ";
            return `${sign}${formatBytes(Math.abs(diff))}`;
          };

          const parseStats = (statsPath, calculateGzip) => {
            if (!fs.existsSync(statsPath)) return {};
            const stats = JSON.parse(fs.readFileSync(statsPath, "utf8"));
            const assetSizes = {};
            (stats.assets || []).forEach((a) => {
              assetSizes[a.name] = a.size;
            });

            const entrypoints = stats.namedChunkGroups || stats.entrypoints || {};
            const routes = {};

            for (const [routeName, chunkGroup] of Object.entries(entrypoints)) {
              const internal = [
                "webpack",
                "main-app",
                "main",
                "polyfills",
                "react-refresh",
                "edge-wrapper",
              ];
              if (internal.some((i) => routeName.includes(i))) continue;

              let totalRaw = 0;
              let totalGzip = 0;

              (chunkGroup.assets || []).forEach((asset) => {
                const assetName = typeof asset === "string" ? asset : asset.name;
                if (assetName.endsWith(".js")) {
                  totalRaw += assetSizes[assetName] || 0;

                  if (calculateGzip) {
                    let filePath = assetName;
                    if (!fs.existsSync(filePath) && !filePath.startsWith(".next")) {
                      filePath = path.join(".next", assetName);
                    }
                    if (fs.existsSync(filePath)) {
                      const fileBuffer = fs.readFileSync(filePath);
                      totalGzip += zlib.gzipSync(fileBuffer).length;
                    } else {
                      console.log(`‚ö†Ô∏è Warning: Could not find file on disk for gzip: ${filePath}`);
                    }
                  }
                }
              });

              if (totalRaw > 0) {
                let cleanRoute = routeName.replace(/^app/, "").replace(/\/page$/, "");
                cleanRoute = cleanRoute === "" ? "/" : cleanRoute;
                routes[cleanRoute] = { raw: totalRaw, gzip: totalGzip };
              }
            }
            return routes;
          };

          const currentRoutes = parseStats(statsPath, true);
          const baselineRoutes = parseStats(
            path.join("_bundle-baseline-stats", "webpack-stats.json"),
            false,
          );

          let markdown = "### üì¶ Next.js App Router Sizes (Turbopack)\n\n";
          markdown += "| Route | Uncompressed | Gzipped | Diff (vs main) |\n|---|---|---|---|\n";

          let foundRoutes = false;
          for (const [route, sizes] of Object.entries(currentRoutes)) {
            foundRoutes = true;
            const baselineSize = baselineRoutes[route]
              ? baselineRoutes[route].raw
              : undefined;
            const diffStr = formatDiff(sizes.raw, baselineSize);
            markdown += `| \`${route}\` | ${formatBytes(sizes.raw)} | **${formatBytes(sizes.gzip)}** | ${diffStr} |\n`;
          }

          if (!foundRoutes) {
            markdown += "> ‚ö†Ô∏è **Warning:** No routes identified. Ensure `TURBOPACK_STATS=1` is set during build.\n";
          }

          fs.writeFileSync("bundle-report.md", markdown);

    - name: Post or update PR comment
      if: github.event_name == 'pull_request'
      uses: marocchino/sticky-pull-request-comment@v2.9.4
      with:
        header: bundle-size-report
        path: bundle-report.md
