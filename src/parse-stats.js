'use strict';

const fs = require('fs');
const path = require('path');
const zlib = require('zlib');

const INTERNAL_CHUNKS = [
  'webpack',
  'main-app',
  'main',
  'polyfills',
  'react-refresh',
  'edge-wrapper',
];

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatPercent(value) {
  return value % 1 === 0 ? value.toFixed(0) : value.toFixed(1);
}

function formatDiff(current, baseline, threshold = 0, budgetPercentIncreaseRed = 0) {
  if (baseline === undefined) return 'üÜï New';
  const diff = current - baseline;
  if (Math.abs(diff) <= threshold) return '‚ûñ No change';
  const percent = (Math.abs(diff) / baseline) * 100;
  if (diff > 0) {
    const icon = percent > budgetPercentIncreaseRed ? 'üî¥' : 'üü°';
    return `${icon} \`+${formatBytes(diff)}\` (+${formatPercent(percent)}%)`;
  }
  return `üü¢ \`-${formatBytes(Math.abs(diff))}\` (-${formatPercent(percent)}%)`;
}

/**
 * Processes a parsed stats object into a routes map.
 *
 * @param {object} stats - Parsed webpack-stats.json content
 * @param {((assetName: string) => number) | null} getGzipSize - Optional
 *   callback returning the gzip size for an asset path. Return 0 if not found.
 * @returns {Record<string, { gzip: number }>}
 */
function processStats(stats, getGzipSize = null) {
  const assetSizes = {};
  (stats.assets || []).forEach((a) => {
    assetSizes[a.name] = a.size;
  });

  const entrypoints = stats.namedChunkGroups || stats.entrypoints || {};
  const routes = {};

  for (const [routeName, chunkGroup] of Object.entries(entrypoints)) {
    if (INTERNAL_CHUNKS.some((chunk) => routeName.includes(chunk))) continue;

    let totalRaw = 0;
    let totalGzip = 0;

    (chunkGroup.assets || []).forEach((asset) => {
      const assetName = typeof asset === 'string' ? asset : asset.name;
      if (!assetName.endsWith('.js')) return;

      totalRaw += assetSizes[assetName] || 0;
      if (getGzipSize) totalGzip += getGzipSize(assetName);
    });

    if (totalRaw === 0) continue;

    let cleanRoute = routeName.replace(/^app/, '').replace(/\/page$/, '');
    cleanRoute = cleanRoute === '' ? '/' : cleanRoute;
    routes[cleanRoute] = { gzip: totalGzip };
  }

  return routes;
}

/**
 * Reads a stats file from disk and processes it.
 *
 * @param {string} statsPath
 * @param {boolean} calculateGzip
 * @returns {Record<string, { gzip: number }>}
 */
function parseStatsFile(statsPath, calculateGzip) {
  if (!fs.existsSync(statsPath)) return {};
  const stats = JSON.parse(fs.readFileSync(statsPath, 'utf8'));

  const getGzipSize = calculateGzip
    ? (assetName) => {
        let filePath = assetName;
        if (!fs.existsSync(filePath) && !filePath.startsWith('.next')) {
          filePath = path.join('.next', assetName);
        }
        if (fs.existsSync(filePath)) {
          return zlib.gzipSync(fs.readFileSync(filePath)).length;
        }
        console.log(`‚ö†Ô∏è Warning: Could not find file on disk for gzip: ${filePath}`);
        return 0;
      }
    : null;

  return processStats(stats, getGzipSize);
}

/**
 * Generates a markdown report comparing current routes to a baseline.
 *
 * @param {Record<string, { gzip: number }>} currentRoutes
 * @param {Record<string, { gzip: number }>} baselineRoutes
 * @param {number} threshold
 * @returns {string}
 */
function generateReport(currentRoutes, baselineRoutes, threshold = 0, budgetPercentIncreaseRed = 0) {
  let markdown = '## üì¶ Next.js App Router Sizes (Turbopack)\n\nThis analysis was generated by the [Next.js Turbopack Bundle Size action](https://github.com/michalsanger/nextjs-turbopack-bundle-size). ü§ñ\n\n';

  const allRoutes = new Set([...Object.keys(currentRoutes), ...Object.keys(baselineRoutes)]);

  if (allRoutes.size === 0) {
    markdown +=
      '> ‚ö†Ô∏è **Warning:** No routes identified. Ensure `TURBOPACK_STATS=1` is set during build.\n';
    return markdown;
  }

  const changedRows = [];
  for (const route of allRoutes) {
    const current = currentRoutes[route];
    const baseline = baselineRoutes[route];

    if (current && baseline === undefined) {
      changedRows.push(`| \`${route}\` | \`${formatBytes(current.gzip)}\` | üÜï New |`);
    } else if (current === undefined && baseline) {
      changedRows.push(`| \`${route}\` | ‚Äî | üóëÔ∏è Removed |`);
    } else if (current && baseline) {
      const diff = Math.abs(current.gzip - baseline.gzip);
      if (diff > threshold) {
        changedRows.push(`| \`${route}\` | \`${formatBytes(current.gzip)}\` | ${formatDiff(current.gzip, baseline.gzip, threshold, budgetPercentIncreaseRed)} |`);
      }
    }
  }

  if (changedRows.length === 0) {
    markdown += 'This PR introduced no changes to the JavaScript bundle! üôå\n';
    return markdown;
  }

  markdown += '| Route | Size (gzipped) | Diff (vs main) |\n|---|---|---|\n';
  markdown += changedRows.join('\n') + '\n';

  return markdown;
}

module.exports = { formatBytes, formatDiff, processStats, parseStatsFile, generateReport };
